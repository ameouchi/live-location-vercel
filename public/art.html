<!DOCTYPE html>
<html>
<head>
  <title>Map – Simulation & Layers</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.14.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.14.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <style>
    body { margin: 0; padding: 0; font-family: sans-serif; }
    #map { position: absolute; top: 0; bottom: 0; left: 220px; right: 0; filter: invert(1) hue-rotate(180deg); }
    #sidebar {
      position: absolute;
      top: 0; left: 0; bottom: 0;
      width: 220px;
      background: rgba(255,255,255,0.95);
      padding: 10px;
      overflow-y: auto;
      z-index: 998;
      border-right: 1px solid #ccc;
    }
    #peopleList { list-style: none; padding: 0; margin: 0; }
    #peopleList li { font-size: 14px; border-bottom: 1px solid #eee; padding: 4px 0; }
    button { margin-top: 10px; }
    .layerToggle, .drawBtn {
      position: absolute;
      top: 20px;
      background: white;
      border: 1px solid #ccc;
      z-index: 999;
      cursor: pointer;
      padding: 6px 12px;
    }
    #bedrockToggle { left: 340px; }
    #v2Toggle { left: 440px; }
    #v3Toggle { left: 540px; }
    #drawBtn { left: 640px; }
    #clearBtn { left: 740px; }
  </style>
</head>
<body>

  <div id="sidebar">
    <h3>Shared Locations</h3>
    
    <div style="margin-bottom: 15px;">
      <input id="name" type="text" placeholder="Enter your name" style="width: 100%; padding: 8px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px;" />
      <button id="shareLocationBtn" style="width: 100%; padding: 8px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Start Sharing Location</button>
      <button id="stopSharingBtn" style="width: 100%; padding: 8px; margin-top: 5px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer; display: none;">Stop Sharing</button>
    </div>
    
    <ul id="peopleList"></ul>
    <button id="startBtn">Start Simulation</button>
    <button id="stopBtn">Stop Sounds</button>
    <button id="enableAudioBtn">Enable Sound</button>
    <button id="testMp3Btn">Test MP3</button>
  </div>

<div id="map"></div>
<button id="bedrockToggle" class="layerToggle">Bedrock: ON</button>
<button id="v2Toggle" class="layerToggle">V2: ON</button>
<button id="v3Toggle" class="layerToggle">V3: ON</button>
<button id="drawBtn" class="drawBtn">Draw Line</button>
<button id="clearBtn" class="drawBtn">Clear</button>

<script>
mapboxgl.accessToken = 'pk.eyJ1IjoibGFtZW91Y2hpIiwiYSI6ImNsa3ZqdHZtMDBjbTQzcXBpNzRyc2ljNGsifQ.287002jl7xT9SBub-dbBbQ';

const map = new mapboxgl.Map({
  container: 'map',
  style: 'mapbox://styles/lameouchi/cme04okvl00be01rydkfj6r43',
  center: [-71.12953, 42.34836],
  zoom: 16
});

/* ---------- MOBILE-FRIENDLY AUDIO INTEGRATION ---------- */
let audioCtx = null;
let masterGain = null;
const playingSources = new Set();
const MAX_SIMULTANEOUS = 6; // tweak for your phone

function createContextIfNeeded() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({latencyHint: 'interactive'});
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 1.0;
    masterGain.connect(audioCtx.destination);
  }
}

async function ensureAudioUnlocked() {
  createContextIfNeeded();
  if (audioCtx.state === 'suspended') {
    try { await audioCtx.resume(); } catch {}
  }
  return audioCtx.state;
}

// Strong unlock: route a real <audio> element through the AudioContext, plus a short beep.
// Must run directly inside a user gesture (the Enable Sound button).
async function strongUnlock() {
  createContextIfNeeded();

  // 1) Real media element (quiet) routed into the context
  const el = document.createElement('audio');
  el.src = '/zone_sound1.mp3';        // use a small/known-valid mp3 that exists on your server
  el.crossOrigin = 'anonymous';
  el.preload = 'auto';
  el.loop = false;
  el.playsInline = true;
  el.muted = false;
  el.volume = 0.05;
  document.body.appendChild(el);

  try {
    const node = audioCtx.createMediaElementSource(el);
    node.connect(masterGain); // goes into the context graph
    await el.play();          // start playback (quiet)
  } catch (e) {
    console.warn('MediaElement unlock failed:', e);
  }

  // 2) Short WebAudio beep
  try {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    gain.gain.value = 0.15;
    osc.frequency.value = 880;
    osc.connect(gain);
    gain.connect(masterGain);
    osc.start();
    setTimeout(() => { try { osc.stop(); } catch {} }, 150);
  } catch (e) {
    console.warn('Oscillator unlock failed:', e);
  }

  // Stop and clean up the element after a moment
  setTimeout(() => {
    try { el.pause(); } catch {}
    el.src = '';
    el.remove();
  }, 1200);
}

// Decode queue to avoid spikes on mobile
const decodeQueue = [];
let decoding = false;

async function loadSoundQueued(url) {
  return new Promise((resolve) => {
    decodeQueue.push({ url, resolve });
    processDecodeQueue();
  });
}
async function processDecodeQueue() {
  if (decoding || decodeQueue.length === 0) return;
  decoding = true;
  const { url, resolve } = decodeQueue.shift();
  try {
    const res = await fetch(url, { cache: 'force-cache' });
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const buf = await res.arrayBuffer();
    createContextIfNeeded();
    const audioBuffer = await audioCtx.decodeAudioData(buf);
    resolve(audioBuffer);
  } catch (e) {
    console.warn('❌ Could not load sound:', url, e.message || e);
    resolve(null);
  } finally {
    decoding = false;
    setTimeout(processDecodeQueue, 50);
  }
}

async function loadSound(url) {
  createContextIfNeeded();
  return loadSoundQueued(url);
}

function startZoneSound(buffer) {
  if (!buffer) return null;
  if (playingSources.size >= MAX_SIMULTANEOUS) {
    const oldest = playingSources.values().next().value;
    try { oldest.stop(0); oldest.disconnect(); } catch {}
    playingSources.delete(oldest);
  }
  const src = audioCtx.createBufferSource();
  src.buffer = buffer;
  src.loop = true;
  src.connect(masterGain || audioCtx.destination);
  src.start(0);
  playingSources.add(src);
  return src;
}

/* ---------- MAP / LAYERS / LOGIC ---------- */
let bedrockZones = [], zoneFlags = [], audioBuffers = [], sources = [];
let drawnCoords = [], isDrawing = false;
let watchId = null; // For location sharing

map.on('load', async () => {
  const loadGeo = async (file) => (await fetch(file)).json();

  // Load bedrock
  const bedrock = await loadGeo('bedrock_depth_vector.geojson');
  bedrockZones = bedrock.features;
  const dns = bedrockZones.map(f => f.properties.DN).filter(Number.isFinite);
  const [min, max] = [Math.min(...dns), Math.max(...dns)];
  const mid = (min + max) / 2;

  // lazy-load buffers on demand for mobile
  audioBuffers = new Array(bedrockZones.length).fill(null);
  zoneFlags   = new Array(bedrockZones.length).fill(false);
  sources     = new Array(bedrockZones.length).fill(null);

  map.addSource('bedrock', { type: 'geojson', data: bedrock });
  map.addLayer({
    id: 'bedrock',
    type: 'fill',
    source: 'bedrock',
    paint: {
      'fill-color': ['interpolate', ['linear'], ['get', 'DN'], min, '#FF0000', mid, '#FFFFFF', max, '#0000FF'],
      'fill-opacity': 0.6, 'fill-outline-color': '#000'
    }
  });

  // V2
  const v2 = await loadGeo('v2.geojson');
  const d2 = v2.features.map(f => f.properties.DN).filter(Number.isFinite);
  const [min2, max2] = [Math.min(...d2), Math.max(...d2)];
  map.addSource('v2layer', { type: 'geojson', data: v2 });
  map.addLayer({
    id: 'v2layer',
    type: 'fill',
    source: 'v2layer',
    paint: {
      'fill-color': ['interpolate', ['linear'], ['get', 'DN'], min2, '#008000', (min2 + max2) / 2, '#FFFF00', max2, '#8B4513'],
      'fill-opacity': 0.4, 'fill-outline-color': '#000'
    }
  });

  // V3
  const v3 = await loadGeo('v3.geojson');
  const d3 = v3.features.map(f => f.properties.DN).filter(Number.isFinite);
  const [min3, max3] = [Math.min(...d3), Math.max(...d3)];
  map.addSource('v3layer', { type: 'geojson', data: v3 });
  map.addLayer({
    id: 'v3layer',
    type: 'fill',
    source: 'v3layer',
    paint: {
      'fill-color': ['interpolate', ['linear'], ['get', 'DN'], min3, '#800080', (min3 + max3) / 2, '#FFC0CB', max3, '#00FFFF'],
      'fill-opacity': 0.4, 'fill-outline-color': '#000'
    }
  });

  // Live line
  map.addSource('live-lines', {
    type: 'geojson',
    data: { type: 'FeatureCollection', features: [] }
  });
  map.addLayer({
    id: 'live-lines',
    type: 'line',
    source: 'live-lines',
    paint: { 'line-color': '#FF0000', 'line-width': 4 }
  });

  map.fitBounds(turf.bbox(bedrock), { padding: 20 });
});

// Fetch new positions and check for sounds
async function updateMap() {
  try {
    const res = await fetch('/api/geo');
    const data = await res.json();
    map.getSource('live-lines').setData(data);

    const peopleList = document.getElementById('peopleList');
    const names = new Set(data.features.map(f => f.properties?.name).filter(Boolean));
    peopleList.innerHTML = '';
    [...names].sort().forEach(name => {
      const li = document.createElement('li');
      li.textContent = name;
      peopleList.appendChild(li);
    });

    data.features.forEach(feature => {
      if (feature?.geometry?.coordinates) {
        const coords = feature.geometry.coordinates;
        const lastCoord = coords[coords.length - 1];
        const pt = turf.point(lastCoord);
        checkSoundZones(pt);
      }
    });
  } catch (err) {
    console.error('Error updating live data', err);
  }
}

// Drawing tool
map.on('click', (e) => {
  if (!isDrawing) return;
  drawnCoords.push([e.lngLat.lng, e.lngLat.lat]);
  const line = {
    type: 'FeatureCollection',
    features: [{
      type: 'Feature',
      geometry: { type: 'LineString', coordinates: drawnCoords }
    }]
  };
  map.getSource('live-lines').setData(line);
});

document.getElementById('drawBtn').onclick = () => {
  isDrawing = true;
  drawnCoords = [];
};

document.getElementById('clearBtn').onclick = () => {
  isDrawing = false;
  drawnCoords = [];
  map.getSource('live-lines').setData({ type: 'FeatureCollection', features: [] });
  stopAllSounds();
};

// Check sound zones for a given point
async function checkSoundZones(pt) {
  for (let i = 0; i < bedrockZones.length; i++) {
    const feature = bedrockZones[i];
    const polygon = turf.polygon(feature.geometry.coordinates);
    const isInside = turf.booleanPointInPolygon(pt, polygon);

    if (isInside && !zoneFlags[i]) {
      if (!audioBuffers[i]) {
        const dn = feature.properties.DN;
        const soundPath = `/zone_sound${dn}.mp3`;
        const buffer = await loadSound(soundPath);
        audioBuffers[i] = buffer;
      }
      if (audioBuffers[i]) {
        const src = startZoneSound(audioBuffers[i]);
        if (src) {
          sources[i] = src;
          zoneFlags[i] = true;
        }
      }
    } else if (!isInside && zoneFlags[i]) {
      if (sources[i]) {
        try { sources[i].stop(0); sources[i].disconnect(); } catch {}
        playingSources.delete(sources[i]);
        sources[i] = null;
      }
      zoneFlags[i] = false;
    }
  }
}

// Audio trigger for drawn coordinates
async function updateSimulation() {
  const coords = drawnCoords.length ? drawnCoords[drawnCoords.length - 1] : null;
  if (!coords) return;
  const pt = turf.point(coords);
  await checkSoundZones(pt);
}

// Controls
document.getElementById('startBtn').onclick = async (e) => {
  // Make sure we unlock immediately on this gesture:
  await strongUnlock();
  setInterval(() => {
    updateSimulation();
    updateMap();
  }, 1200);
};

document.getElementById('stopBtn').onclick = () => {
  stopAllSounds();
};

document.getElementById('enableAudioBtn').onclick = async () => {
  await strongUnlock();
  alert('Sound enabled. If you still hear nothing on iPhone, flip the ring/silent switch to RING and raise volume.');
};

document.getElementById('testMp3Btn').onclick = async () => {
  const el = new Audio('/zone_sound1.mp3'); // change if needed
  el.playsInline = true;
  el.crossOrigin = 'anonymous';
  try { await el.play(); } catch(e) { console.warn('MP3 test failed', e); }
  setTimeout(() => { try { el.pause(); el.src=''; } catch{} }, 1500);
};

// Location sharing functionality
document.getElementById('shareLocationBtn').onclick = () => {
  const name = document.getElementById('name').value.trim();
  if (!name) return alert('Enter your name');
  if (!navigator.geolocation) return alert('Geolocation not supported');

  watchId = navigator.geolocation.watchPosition(pos => {
    console.log("Sending position:", pos.coords);
    fetch('/api/geo', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        name,
        coords: {
          lat: pos.coords.latitude,
          lng: pos.coords.longitude
        },
        timestamp: Date.now()
      })
    });
  }, error => {
    console.error("Geolocation error", error);
  }, {
    enableHighAccuracy: true,
    maximumAge: 1000,
    timeout: 5000
  });

  // Update UI
  document.getElementById('shareLocationBtn').style.display = 'none';
  document.getElementById('stopSharingBtn').style.display = 'block';
  document.getElementById('name').disabled = true;
};

document.getElementById('stopSharingBtn').onclick = () => {
  if (watchId !== null) {
    navigator.geolocation.clearWatch(watchId);
    watchId = null;
    
    // Update UI
    document.getElementById('shareLocationBtn').style.display = 'block';
    document.getElementById('stopSharingBtn').style.display = 'none';
    document.getElementById('name').disabled = false;
  }
};

function stopAllSounds() {
  sources.forEach((src, i) => {
    if (src) {
      try { src.stop(0); src.disconnect(); } catch {}
      playingSources.delete(src);
      sources[i] = null;
    }
    zoneFlags[i] = false;
  });
  for (const src of Array.from(playingSources)) {
    try { src.stop(0); src.disconnect(); } catch {}
    playingSources.delete(src);
  }
}

// Toggle layer visibility
function toggleLayer(id, btnId, label) {
  const vis = map.getLayoutProperty(id, 'visibility') || 'visible';
  const newVis = vis === 'visible' ? 'none' : 'visible';
  map.setLayoutProperty(id, 'visibility', newVis);
  document.getElementById(btnId).textContent = `${label}: ${newVis === 'visible' ? 'ON' : 'OFF'}`;
}
document.getElementById('bedrockToggle').onclick = () => toggleLayer('bedrock', 'bedrockToggle', 'Bedrock');
document.getElementById('v2Toggle').onclick = () => toggleLayer('v2layer', 'v2Toggle', 'V2');
document.getElementById('v3Toggle').onclick = () => toggleLayer('v3layer', 'v3Toggle', 'V3');
</script>
</body>
</html>
