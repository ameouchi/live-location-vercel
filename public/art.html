<!DOCTYPE html>
<html>
<head>
  <title>Map â€“ Shared Locations + Zones + Simulator</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.14.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.14.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <style>
    body { margin: 0; padding: 0; font-family: sans-serif; }
    #map { position: absolute; top: 0; bottom: 0; left: 250px; right: 0; filter: invert(1) hue-rotate(180deg); }
    #sidebar {
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      width: 250px;
      background: rgba(255,255,255,0.95);
      padding: 10px;
      overflow-y: auto;
      z-index: 998;
      border-right: 1px solid #ccc;
    }
    #sidebar h3 { margin-top: 0; font-size: 16px; }
    #peopleList li { padding: 4px 0; font-size: 14px; border-bottom: 1px solid #eee; }

    #controls {
      position: absolute;
      top: 20px;
      left: 260px;
      z-index: 999;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    button {
      padding: 6px 12px;
      background: white;
      border: 1px solid #ccc;
      cursor: pointer;
    }
  </style>
</head>
<body>

<div id="sidebar">
  <h3>Shared Locations</h3>
  <ul id="peopleList"></ul>
</div>

<div id="controls">
  <button id="startBtn">Start Audio</button>
  <button id="stopBtn">Stop Audio</button>
  <button id="drawBtn">Start Drawing</button>
  <button id="clearBtn">Clear</button>
</div>

<div id="map"></div>

<script>
mapboxgl.accessToken = 'pk.eyJ1IjoibGFtZW91Y2hpIiwiYSI6ImNsa3ZqdHZtMDBjbTQzcXBpNzRyc2ljNGsifQ.287002jl7xT9SBub-dbBbQ';

const map = new mapboxgl.Map({
  container: 'map',
  style: 'mapbox://styles/mapbox/light-v11',
  center: [-71.12953, 42.34836],
  zoom: 16
});

let bedrockZones = [];
let audioContext;
let audioBuffers = [];
let audioSources = [];
let zoneFlags = [];

let simulatedLine = {
  type: 'Feature',
  geometry: { type: 'LineString', coordinates: [] },
  properties: { name: 'Simulator' }
};

map.on('load', async () => {
  // Load Bedrock
  const bedrock = await fetch('bedrock_depth_vector.geojson').then(res => res.json());
  bedrockZones = bedrock.features;

  const dnValues = bedrockZones.map(f => f.properties.DN).filter(v => typeof v === 'number');
  const [min, max] = [Math.min(...dnValues), Math.max(...dnValues)];
  const mid = (min + max) / 2;

  zoneFlags = new Array(bedrockZones.length).fill(false);
  audioSources = new Array(bedrockZones.length).fill(null);

  map.addSource('bedrock', { type: 'geojson', data: bedrock });
  map.addLayer({
    id: 'bedrock',
    type: 'fill',
    source: 'bedrock',
    paint: {
      'fill-color': ['interpolate', ['linear'], ['get', 'DN'], min, '#FF0000', mid, '#FFFFFF', max, '#0000FF'],
      'fill-opacity': 0.5,
      'fill-outline-color': '#000000'
    }
  });

  // Load V2
  const v2 = await fetch('v2.geojson').then(res => res.json());
  const v2DNs = v2.features.map(f => f.properties.DN).filter(v => typeof v === 'number');
  const [min2, max2] = [Math.min(...v2DNs), Math.max(...v2DNs)];
  const mid2 = (min2 + max2) / 2;

  map.addSource('v2', { type: 'geojson', data: v2 });
  map.addLayer({
    id: 'v2',
    type: 'fill',
    source: 'v2',
    paint: {
      'fill-color': ['interpolate', ['linear'], ['get', 'DN'], min2, '#00FF00', mid2, '#FFFF00', max2, '#8B4513'],
      'fill-opacity': 0.4,
      'fill-outline-color': '#000000'
    }
  });

  // Load V3
  const v3 = await fetch('v3.geojson').then(res => res.json());
  const v3DNs = v3.features.map(f => f.properties.DN).filter(v => typeof v === 'number');
  const [min3, max3] = [Math.min(...v3DNs), Math.max(...v3DNs)];
  const mid3 = (min3 + max3) / 2;

  map.addSource('v3', { type: 'geojson', data: v3 });
  map.addLayer({
    id: 'v3',
    type: 'fill',
    source: 'v3',
    paint: {
      'fill-color': ['interpolate', ['linear'], ['get', 'DN'], min3, '#800080', mid3, '#FFC0CB', max3, '#00FFFF'],
      'fill-opacity': 0.4,
      'fill-outline-color': '#000000'
    }
  });

  // Add simulation line
  map.addSource('sim-line', {
    type: 'geojson',
    data: { type: 'FeatureCollection', features: [simulatedLine] }
  });
  map.addLayer({
    id: 'sim-line',
    type: 'line',
    source: 'sim-line',
    paint: {
      'line-color': '#FF00FF',
      'line-width': 4
    }
  });

  map.fitBounds(turf.bbox(bedrock), { padding: 20 });
});

document.getElementById('startBtn').addEventListener('click', async () => {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  await audioContext.resume();

  for (let i = 0; i < bedrockZones.length; i++) {
    const dn = bedrockZones[i].properties.DN;
    try {
      const response = await fetch(`/zone_sound${dn}.mp3`);
      const arrayBuffer = await response.arrayBuffer();
      audioBuffers[i] = await audioContext.decodeAudioData(arrayBuffer);
    } catch {
      console.warn(`âš ï¸ Failed to load zone_sound${dn}.mp3`);
      audioBuffers[i] = null;
    }
  }
  console.log('âœ… Sounds loaded');
});

document.getElementById('stopBtn').addEventListener('click', () => {
  for (let i = 0; i < audioSources.length; i++) {
    if (audioSources[i]) {
      audioSources[i].stop();
      audioSources[i].disconnect();
      audioSources[i] = null;
      zoneFlags[i] = false;
    }
  }
  console.log('ðŸ”‡ All sounds stopped');
});

let drawing = false;
document.getElementById('drawBtn').addEventListener('click', () => {
  drawing = !drawing;
  document.getElementById('drawBtn').textContent = drawing ? 'Drawing: ON' : 'Start Drawing';
});

document.getElementById('clearBtn').addEventListener('click', () => {
  simulatedLine.geometry.coordinates = [];
  map.getSource('sim-line').setData({ type: 'FeatureCollection', features: [simulatedLine] });
});

map.on('click', (e) => {
  if (!drawing) return;
  simulatedLine.geometry.coordinates.push([e.lngLat.lng, e.lngLat.lat]);
  map.getSource('sim-line').setData({ type: 'FeatureCollection', features: [simulatedLine] });
  checkZones(e.lngLat.lng, e.lngLat.lat);
});

function checkZones(lng, lat) {
  if (!audioContext) return;
  const pt = turf.point([lng, lat]);
  bedrockZones.forEach((feature, i) => {
    const polygon = turf.feature(feature.geometry);
    const inside = turf.booleanPointInPolygon(pt, polygon);

    if (inside && !zoneFlags[i] && audioBuffers[i]) {
      const source = audioContext.createBufferSource();
      source.buffer = audioBuffers[i];
      source.loop = true;
      source.connect(audioContext.destination);
      source.start();
      audioSources[i] = source;
      zoneFlags[i] = true;
    } else if (!inside && zoneFlags[i]) {
      if (audioSources[i]) {
        audioSources[i].stop();
        audioSources[i].disconnect();
        audioSources[i] = null;
      }
      zoneFlags[i] = false;
    }
  });
}
</script>

</body>
</html>
