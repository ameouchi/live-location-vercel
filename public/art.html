<!DOCTYPE html>
<html>
<head>
  <title>Map – Simulation & Layers (iOS-safe WebAudio)</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.14.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.14.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <style>
    :root { --ui:#111; --bg:#fff; --acc:#eaeef3; --btn:#0f62fe; --danger:#e63946; }
    *{ box-sizing:border-box; }
    body{ margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
    #map{ position:absolute; top:0; bottom:0; left:260px; right:0; filter: invert(1) hue-rotate(180deg); }
    #sidebar{ position:absolute; inset:0 auto 0 0; width:260px; background:var(--bg); border-right:1px solid #ddd; padding:12px; overflow-y:auto; z-index:998; }
    h3{ margin:6px 0 10px; font-size:16px; color:var(--ui); }
    .group{ background:#fff; border:1px solid #ddd; border-radius:10px; padding:10px; margin-bottom:10px; }
    .row{ display:flex; gap:8px; }
    .row>*{ flex:1; }
    input[type="text"]{ width:100%; padding:8px 10px; border:1px solid #ccc; border-radius:8px; }
    button{ padding:8px 10px; border-radius:8px; border:1px solid #ccc; background:#fff; cursor:pointer; }
    .primary{ background:var(--btn); color:#fff; border-color:var(--btn); }
    .danger{ background:var(--danger); color:#fff; border-color:var(--danger); }
    .ghost{ background:#fff; color:#111; border:1px solid #bbb; }
    .hint{ font-size:12px; color:#666; margin-top:6px; }
    #peopleList{ list-style:none; padding:0; margin:0; max-height:120px; overflow:auto; border-top:1px dashed #ddd; }
    #peopleList li{ font-size:13px; padding:4px 0; border-bottom:1px dashed #eee; }
    .layerToggle,.drawBtn{ position:absolute; top:12px; background:#fff; border:1px solid #ccc; z-index:999; cursor:pointer; padding:6px 10px; border-radius:8px; }
    #bedrockToggle{ left:280px; }
    #v2Toggle{ left:380px; }
    #v3Toggle{ left:480px; }
    #drawBtn{ left:580px; }
    #clearBtn{ left:680px; }
    #ctxState{ font-size:12px; color:#555; margin-left:6px; }
  </style>
</head>
<body>

  <div id="sidebar">
    <h3>Shared Locations <span id="ctxState">Audio: —</span></h3>

    <div class="group">
      <div class="row" style="margin-bottom:8px;">
        <input id="name" type="text" placeholder="Enter your name" />
      </div>
      <div class="row">
        <button id="shareLocationBtn" class="primary">Start Sharing Location</button>
        <button id="stopSharingBtn" class="danger" style="display:none;">Stop</button>
      </div>
      <div class="hint">Mobile requires HTTPS or localhost for GPS.</div>
    </div>

    <div class="group">
      <div class="row">
        <button id="startBtn" class="primary">▶ Start</button>
        <button id="stopBtn"  class="ghost">■ Stop Sounds</button>
      </div>
      <div class="row" style="margin-top:8px;">
        <button id="enableAudioBtn" class="ghost">🔊 Enable Sound</button>
        <button id="testMp3Btn" class="ghost">Test MP3</button>
      </div>
      <div class="hint">On iPhone, flip the ring/silent switch to <b>Ring</b> and raise volume.</div>
    </div>

    <div class="group">
      <strong>People</strong>
      <ul id="peopleList"></ul>
    </div>
  </div>

  <div id="map"></div>
  <button id="bedrockToggle" class="layerToggle">Bedrock: ON</button>
  <button id="v2Toggle" class="layerToggle">V2: ON</button>
  <button id="v3Toggle" class="layerToggle">V3: ON</button>
  <button id="drawBtn" class="drawBtn">Draw Line</button>
  <button id="clearBtn" class="drawBtn">Clear</button>

<script>
/* ---------------- MAPBOX INIT ---------------- */
mapboxgl.accessToken = 'pk.eyJ1IjoibGFtZW91Y2hpIiwiYSI6ImNsa3ZqdHZtMDBjbTQzcXBpNzRyc2ljNGsifQ.287002jl7xT9SBub-dbBbQ';

const map = new mapboxgl.Map({
  container: 'map',
  style: 'mapbox://styles/lameouchi/cme04okvl00be01rydkfj6r43',
  center: [-71.12953, 42.34836],
  zoom: 16
});

/* ---------------- AUDIO (iOS-safe) ---------------- */
let audioCtx = null, masterGain = null;
const playingSources = new Set(); // holds {src, gain}
const MAX_SIMULTANEOUS = 6;
let interactionBound = false;

function updateCtxBadge() {
  const el = document.getElementById('ctxState');
  if (el && audioCtx) el.textContent = `Audio: ${audioCtx.state}`;
}

function createContextIfNeeded() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 1.0;
    masterGain.connect(audioCtx.destination);

    // Inaudible keep-alive that actually reaches DAC (helps Safari stay "running")
    const keepAliveOsc = audioCtx.createOscillator();
    const keepAliveGain = audioCtx.createGain();
    keepAliveOsc.type = 'sine';
    keepAliveOsc.frequency.value = 30;
    keepAliveGain.gain.value = 0.0003;
    keepAliveOsc.connect(keepAliveGain).connect(masterGain);
    try { keepAliveOsc.start(); } catch {}

    audioCtx.onstatechange = updateCtxBadge;
    updateCtxBadge();
  }
}
async function ensureAudioUnlocked() {
  createContextIfNeeded();
  if (audioCtx.state === 'suspended') {
    try { await audioCtx.resume(); } catch {}
  }
  updateCtxBadge();
  return audioCtx.state;
}

// One-time global unlock on the very first user interaction anywhere
function bindFirstInteractionUnlock() {
  if (interactionBound) return;
  interactionBound = true;
  const onceUnlock = async () => {
    document.removeEventListener('pointerdown', onceUnlock);
    document.removeEventListener('touchend', onceUnlock);
    await strongUnlock();
  };
  document.addEventListener('pointerdown', onceUnlock, { once: true });
  document.addEventListener('touchend', onceUnlock, { once: true });
}
// bind immediately
bindFirstInteractionUnlock();

// Strong unlock sequence: play a tiny real <audio>, beep via WebAudio, and briefly auto-resume
async function strongUnlock() {
  createContextIfNeeded();

  // 1) Real media element
  const el = document.createElement('audio');
  el.src = '/zone_sound1.mp3';  // must exist; serve as Content-Type: audio/mpeg
  el.preload = 'auto';
  el.crossOrigin = 'anonymous';
  el.playsInline = true;
  el.controls = false;
  el.muted = false;
  el.volume = 0.01;
  document.body.appendChild(el);

  try {
    const node = audioCtx.createMediaElementSource(el);
    node.connect(masterGain);
    await el.play();
  } catch (e) {
    console.warn('MediaElement unlock failed:', e);
  }

  // 2) Short WebAudio beep
  try {
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    g.gain.value = 0.08;
    osc.frequency.value = 880;
    osc.connect(g).connect(masterGain);
    osc.start();
    setTimeout(() => { try { osc.stop(); } catch{} }, 120);
  } catch (e) {
    console.warn('Oscillator unlock failed:', e);
  }

  // 3) Keep resuming for ~2s (some iOS Safari builds re-suspend immediately)
  const t0 = performance.now();
  const tick = async () => {
    if (!audioCtx) return;
    if (audioCtx.state !== 'running') {
      try { await audioCtx.resume(); } catch {}
    }
    updateCtxBadge();
    if (performance.now() - t0 < 2000) requestAnimationFrame(tick);
  };
  tick();

  setTimeout(() => { try { el.pause(); } catch{} el.src=''; el.remove(); }, 1500);
}

/* ---------- Decode queue to avoid mobile stalls ---------- */
const decodeQueue = [];
let decoding = false;
function loadSoundQueued(url) {
  return new Promise((resolve) => {
    decodeQueue.push({ url, resolve });
    processDecodeQueue();
  });
}
async function processDecodeQueue() {
  if (decoding || decodeQueue.length === 0) return;
  decoding = true;
  const { url, resolve } = decodeQueue.shift();
  try {
    const res = await fetch(url, { cache: 'force-cache' });
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const buf = await res.arrayBuffer();
    createContextIfNeeded();
    const audioBuffer = await audioCtx.decodeAudioData(buf);
    resolve(audioBuffer);
  } catch (e) {
    console.warn('❌ Could not load sound:', url, e.message || e);
    resolve(null);
  } finally {
    decoding = false;
    setTimeout(processDecodeQueue, 50);
  }
}
async function loadSound(url) { createContextIfNeeded(); return loadSoundQueued(url); }

/* ---------- Start/stop with per-sound fades ---------- */
function startZoneSound(buffer) {
  if (!buffer) return null;

  if (playingSources.size >= MAX_SIMULTANEOUS) {
    // Stop oldest
    const oldest = playingSources.values().next().value;
    try { oldest.src.stop(0); oldest.src.disconnect(); oldest.gain.disconnect(); } catch {}
    playingSources.delete(oldest);
  }

  const src = audioCtx.createBufferSource();
  const g = audioCtx.createGain();
  g.gain.setValueAtTime(0, audioCtx.currentTime);
  g.gain.linearRampToValueAtTime(1, audioCtx.currentTime + 0.15); // fade in

  src.buffer = buffer;
  src.loop = true;
  src.connect(g).connect(masterGain || audioCtx.destination);
  src.start(0);

  const handle = { src, gain: g };
  playingSources.add(handle);
  return handle;
}
function stopHandle(handle) {
  if (!handle) return;
  try {
    const now = audioCtx.currentTime;
    handle.gain.gain.cancelScheduledValues(now);
    const current = handle.gain.gain.value;
    handle.gain.gain.setValueAtTime(current, now);
    handle.gain.gain.linearRampToValueAtTime(0, now + 0.12); // fade out
    setTimeout(() => {
      try { handle.src.stop(0); handle.src.disconnect(); handle.gain.disconnect(); } catch {}
      playingSources.delete(handle);
    }, 130);
  } catch {}
}
function stopAllSounds() {
  for (const h of Array.from(playingSources)) stopHandle(h);
}

/* ---------------- MAP / DATA / SOUND ---------------- */
let bedrockZones = [], zoneFlags = [], audioBuffers = [], sources = [];
let drawnCoords = [], isDrawing = false;

map.on('load', async () => {
  const loadGeo = async (file) => (await fetch(file)).json();

  // Bedrock
  const bedrock = await loadGeo('bedrock_depth_vector.geojson');
  bedrockZones = bedrock.features || [];
  const dns = bedrockZones.map(f => f?.properties?.DN).filter(Number.isFinite);
  const [min, max] = [Math.min(...dns), Math.max(...dns)];
  const mid = (min + max) / 2;

  audioBuffers = new Array(bedrockZones.length).fill(null);
  zoneFlags   = new Array(bedrockZones.length).fill(false);
  sources     = new Array(bedrockZones.length).fill(null);

  map.addSource('bedrock', { type:'geojson', data: bedrock });
  map.addLayer({
    id:'bedrock', type:'fill', source:'bedrock',
    paint:{ 'fill-color':['interpolate',['linear'],['get','DN'],min,'#FF0000',mid,'#FFFFFF',max,'#0000FF'],
            'fill-opacity':0.6, 'fill-outline-color':'#000' }
  });

  // V2
  const v2 = await loadGeo('v2.geojson');
  const d2 = (v2.features||[]).map(f => f?.properties?.DN).filter(Number.isFinite);
  const [min2, max2] = [Math.min(...d2), Math.max(...d2)];
  map.addSource('v2layer', { type:'geojson', data: v2 });
  map.addLayer({
    id:'v2layer', type:'fill', source:'v2layer',
    paint:{ 'fill-color':['interpolate',['linear'],['get','DN'],min2,'#008000',(min2+max2)/2,'#FFFF00',max2,'#8B4513'],
            'fill-opacity':0.4, 'fill-outline-color':'#000' }
  });

  // V3
  const v3 = await loadGeo('v3.geojson');
  const d3 = (v3.features||[]).map(f => f?.properties?.DN).filter(Number.isFinite);
  const [min3, max3] = [Math.min(...d3), Math.max(...d3)];
  map.addSource('v3layer', { type:'geojson', data: v3 });
  map.addLayer({
    id:'v3layer', type:'fill', source:'v3layer',
    paint:{ 'fill-color':['interpolate',['linear'],['get','DN'],min3,'#800080',(min3+max3)/2,'#FFC0CB',max3,'#00FFFF'],
            'fill-opacity':0.4, 'fill-outline-color':'#000' }
  });

  // Live line (drawn + live people)
  map.addSource('live-lines', { type:'geojson', data:{ type:'FeatureCollection', features:[] }});
  map.addLayer({ id:'live-lines', type:'line', source:'live-lines',
    paint:{ 'line-color':'#FF0000', 'line-width':4 } });

  if (bedrock.features?.length) {
    map.fitBounds(turf.bbox(bedrock), { padding:20 });
  }
});

/* ---------------- Zone checks ---------------- */
async function checkSoundZones(pt) {
  for (let i = 0; i < bedrockZones.length; i++) {
    const feature = bedrockZones[i];
    const polygon = turf.polygon(feature.geometry.coordinates);
    const isInside = turf.booleanPointInPolygon(pt, polygon);

    if (isInside && !zoneFlags[i]) {
      if (!audioBuffers[i]) {
        const dn = feature.properties.DN;
        audioBuffers[i] = await loadSound(`/zone_sound${dn}.mp3`);
      }
      if (audioBuffers[i]) {
        const handle = startZoneSound(audioBuffers[i]);
        if (handle) { sources[i] = handle; zoneFlags[i] = true; }
      }
    } else if (!isInside && zoneFlags[i]) {
      if (sources[i]) { stopHandle(sources[i]); sources[i] = null; }
      zoneFlags[i] = false;
    }
  }
}

/* ---------------- Live data + list + triggers ---------------- */
async function updateMap() {
  try {
    const res = await fetch('/api/geo');
    const data = await res.json();
    const src = map.getSource('live-lines');
    if (src) src.setData(data);

    // People list
    const peopleList = document.getElementById('peopleList');
    const names = new Set((data.features||[]).map(f => f.properties?.name).filter(Boolean));
    peopleList.innerHTML = '';
    [...names].sort().forEach(name => {
      const li = document.createElement('li'); li.textContent = name; peopleList.appendChild(li);
    });

    // Zone checks (each last point)
    (data.features||[]).forEach(feature => {
      const coords = feature?.geometry?.coordinates;
      if (coords && coords.length) {
        const lastCoord = coords[coords.length - 1];
        const pt = turf.point(lastCoord);
        checkSoundZones(pt);
      }
    });
  } catch (err) {
    console.error('Error updating live data', err);
  }
}

/* ---------------- Draw tool to manually trigger zones ---------------- */
map.on('click', (e) => {
  if (!isDrawing) return;
  drawnCoords.push([e.lngLat.lng, e.lngLat.lat]);
  const line = { type:'FeatureCollection', features:[{ type:'Feature', geometry:{ type:'LineString', coordinates: drawnCoords } }] };
  const src = map.getSource('live-lines');
  if (src) src.setData(line);
});
document.getElementById('drawBtn').onclick = () => { isDrawing = true; drawnCoords = []; };
document.getElementById('clearBtn').onclick = () => {
  isDrawing = false; drawnCoords = [];
  const src = map.getSource('live-lines');
  if (src) src.setData({ type:'FeatureCollection', features:[] });
  stopAllSounds();
};

async function updateSimulation() {
  if (!drawnCoords.length) return;
  const pt = turf.point(drawnCoords[drawnCoords.length - 1]);
  await ensureAudioUnlocked();
  await checkSoundZones(pt);
}

/* ---------------- Controls ---------------- */
let mainTimer = null;

document.getElementById('startBtn').onclick = async () => {
  await strongUnlock();

  // Optional: pre-warm a few sounds to avoid first-hit lag
  ['/zone_sound1.mp3','/zone_sound2.mp3','/zone_sound3.mp3'].forEach(url => loadSound(url));

  if (mainTimer) return; // already running
  let lastResume = 0;
  mainTimer = setInterval(async () => {
    if (audioCtx && audioCtx.state !== 'running') {
      const now = performance.now();
      if (now - lastResume > 1000) {
        try { await audioCtx.resume(); } catch {}
        lastResume = now;
        updateCtxBadge();
      }
    }
    updateSimulation();
    updateMap();
  }, 1200);
};

document.getElementById('stopBtn').onclick = () => {
  stopAllSounds();
  if (mainTimer) { clearInterval(mainTimer); mainTimer = null; }
  // Optionally: audioCtx?.suspend(); // battery saver
};

document.getElementById('enableAudioBtn').onclick = async () => {
  await strongUnlock();
  alert('Sound enabled. If still silent on iPhone, set ring switch to RING and raise volume.');
};

document.getElementById('testMp3Btn').onclick = async () => {
  const el = new Audio('/zone_sound1.mp3');
  el.playsInline = true; el.crossOrigin = 'anonymous';
  try { await el.play(); } catch(e) { console.warn('MP3 test failed', e); }
  setTimeout(() => { try { el.pause(); el.src=''; } catch{} }, 1500);
};

/* ---------------- Layer toggles ---------------- */
function toggleLayer(id, btnId, label) {
  const vis = map.getLayoutProperty(id, 'visibility') || 'visible';
  const newVis = vis === 'visible' ? 'none' : 'visible';
  map.setLayoutProperty(id, 'visibility', newVis);
  document.getElementById(btnId).textContent = `${label}: ${newVis === 'visible' ? 'ON' : 'OFF'}`;
}
document.getElementById('bedrockToggle').onclick = () => toggleLayer('bedrock', 'bedrockToggle', 'Bedrock');
document.getElementById('v2Toggle').onclick = () => toggleLayer('v2layer', 'v2Toggle', 'V2');
document.getElementById('v3Toggle').onclick = () => toggleLayer('v3layer', 'v3Toggle', 'V3');

/* ---------------- Location sharing (robust) ---------------- */
const nameInput = document.getElementById('name');
const shareBtn  = document.getElementById('shareLocationBtn');
const stopShareBtn = document.getElementById('stopSharingBtn');

let watchId = null, lastSentAt = 0, lastCoords = null;

function isSecureContextForGeo() {
  return location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
}
function requestGeoOnce() {
  return new Promise((resolve, reject) => {
    navigator.geolocation.getCurrentPosition(
      () => resolve(true),
      (err) => reject(err),
      { enableHighAccuracy: true, timeout: 8000, maximumAge: 0 }
    );
  });
}
async function startSharing() {
  const name = nameInput.value.trim();
  if (!name) return alert('Enter your name');
  if (!('geolocation' in navigator)) return alert('Geolocation not supported.');
  if (!isSecureContextForGeo()) return alert('Use HTTPS or localhost for mobile GPS.');

  try { await requestGeoOnce(); }
  catch (e) { console.error('Initial geolocation failed:', e); alert('Location permission denied or unavailable.'); return; }

  shareBtn.style.display = 'none';
  stopShareBtn.style.display = 'inline-block';
  nameInput.disabled = true;

  const MIN_INTERVAL_MS = 2000;

  watchId = navigator.geolocation.watchPosition(async (pos) => {
    const now = Date.now();
    const coords = { lat: pos.coords.latitude, lng: pos.coords.longitude };
    const sameAsLast = lastCoords &&
      Math.abs(coords.lat - lastCoords.lat) < 1e-7 &&
      Math.abs(coords.lng - lastCoords.lng) < 1e-7;
    if (now - lastSentAt < MIN_INTERVAL_MS && sameAsLast) return;

    lastCoords = coords; lastSentAt = now;

    try {
      const res = await fetch('/api/geo', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, coords, timestamp: now }),
        keepalive: true
      });
      if (!res.ok) console.warn('POST /api/geo failed:', res.status, res.statusText);
    } catch (err) {
      console.warn('Sending location failed:', err);
    }
  }, (err) => {
    console.error('watchPosition error:', err);
    alert('Location error: ' + (err.message || err));
    stopSharing();
  }, { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 });
}
function stopSharing() {
  if (watchId !== null) {
    navigator.geolocation.clearWatch(watchId);
    watchId = null;
  }
  shareBtn.style.display = 'inline-block';
  stopShareBtn.style.display = 'none';
  nameInput.disabled = false;
}
shareBtn.onclick = startSharing;
stopShareBtn.onclick = stopSharing;

window.addEventListener('pagehide', () => {
  try {
    navigator.sendBeacon?.('/api/geo', JSON.stringify({
      name: nameInput.value.trim(),
      stop: true,
      timestamp: Date.now()
    }));
  } catch {}
});

/* ---------------- Page visibility/focus: auto-resume ---------------- */
document.addEventListener('visibilitychange', async () => {
  if (document.visibilityState === 'visible') {
    try { await ensureAudioUnlocked(); } catch {}
  }
});
window.addEventListener('focus', async () => {
  try { await ensureAudioUnlocked(); } catch {}
});
</script>
</body>
</html>
